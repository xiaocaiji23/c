# 一.初识 C 语言 
## 1 .C 语言的起源
- 1972年,贝尔实验室的**丹尼斯·里奇**(Dennis Ritch)和**肯·汤普逊** (Ken Thompson)在开发 **UNIX 操作系统**时设计了 C 语言
- 在**B 语言**的基础上进行设计
## 2. 选择 C 语言的理由
- ### 设计特性
	- 易懂
	- 可靠
- ### 高效性
	- 相对紧凑
		- 原因：在设计上充分利用当前计算机的优势
	- 运行时间**快**
	- 微调控制能力**汇编语言**特性（**可以根据具体情况微调程序获得最大运行速度或最有效地使用内存**）
	- **汇编语言**: 为特殊的中央处理单元设计的⼀系列内部指令, 使用助记符来表示
		- 不同的 CPU 系列使用不同的汇编语言
- ### 可移植性
	- 意味着：**在⼀种系统中编写的 C 程序稍作修改或不修改就能在其他系统运行;如需修改,也只需简单更改主程序头文件中的少许项即可**
- ### 强大而灵活
	- **UNIX 操作系统**,大部分是用 C 语言写的
	- 其他语言 (如 FORTRAN,Perl,Python、Pascal,LISP,Logo,BASIC)的许多**编译器**和**解释器**都是用 C 语言编写的
	- **编译器**:把 C 代码转换成计算机**内部指令**的程序
- ### 面向程序员
	- **优点**:许多任务用 C 来处理都非常**简洁** (例如:转换数据的格式）
	- **缺点**: C 语言使用**指针**, 易犯错, 难察觉
## 3.C 语言的应用范围
- C 语言是**嵌入式系统编程**的流行语言
- C 语言还从长期被 FORTRAN 独占的**科学编程领域**分得一杯羹
## 4. 使用C 语言的7个步骤
- *1. 定义程序的目标; 2. 设计程序; 3. 编写代码; 4. 编译; 5. 运行程序; 6. 测试和调试程序; 7. 维护和修改程序*
	- **源代码**![[Pasted image 20230828171855.png]] (通过编译器转化成**目标代码**)文件中的内容就是你翻译的 C 语言代码 
	- **可执行代码**:用计算机的**机器语言**表示的代码
	- **C 编译器**:将源代码与C 库的代码合并成最终程序 
	- **运行程序**需要**集成开发环境**(IDE)
	- **调试**:查找并修复程序错误的过程
## 5.编程机制
-  ![[Pasted image 20230914170820.png]]
- **源代码文件**:编写程序时, 存储编写的内容的文本文件
- **目标代码文件**:存储机器语言代码 (由源代码转换)的文件
	- **基本名**:点号 (.)前面的部分
	- **扩展名**:点号后面的部分
- **启动代码**:程序和操作系统间的接口
- **链接器**的作用:把编写的目标代码(大括号内的代码),系统的标准启动代码（`#include <stdio.h >` 和 `int main()`）和库代码合并成<font color="#ffff00">可执行文件</font>
	- 链接器只提取程序中要用到的**库函数代码**
# 二.C 语言概述
## 1. 代码含义
- ![[Pasted image 20230901014006.png]]
-  `#include<stdio.h>` 告诉编译器把 stdio. h 中的内容包含在当前程序 
	- `#include <stdio.h>` 是一条 C **预处理器指令**
	- stdio.h (**标准输出/输入头文件**)包含编译器使用的函数信息
-  `int main(void)` 函数是 C 程序的基本模块
	- main()是函数名
	- int 表示 main()函数返回一个整数 
	- void 表示 main()不带任何参数
	- 旧式的代码会出现 `main()` 和 `void main()` 
- `/*这是一段的注释*/` 和 `//这是一行的注释` 编译器会忽略
-  `{这里面是函数体}`; `int num` 声明变量类型; `num=1;` 赋值表达语句;
	- 花括号{}还可用于把函数中的多个语句合并为有一个单元或块 (复合语句)
	- **声明**是 C 语言最重要的特性之一; `int` 是 C 语言中的一个**关键字**; `num` 是一个**标识符**
- **命名**
	- 能清楚地表达自身的用途
	- 可以用**小写字母, 大写字母, 数字, 下划线** (`__`) 来命名
	- 首个字符必须是字母或下划线; 不能是数字
	- 不能使用**关键字**和**保留标识符**
- **声明变量**: 未提前声明变量,将无法通过编译
- **调用函数**: 在程序中使用函数
- **预处理**: C 编译器在编译前对源代码做的准备工作
- **头文件**: 在 C 程序顶部的信息集合
-  `return 0;` 在有返回值的函数中一定要有 
## 2. 提高程序的可读性  
- 选择有意义的函数名和写注释  
- 在函数中用空行分隔概念上的多个部分  
- 每条语句各占一行  
## 3. 多个函数     
- **程序状态**:在程序的执行过程中,某给定点上所有变量值的集合  
- **调试器**是一种程序, 可以一步步运行一个程序,并检查该程序变量的值
## 4. 关键字和保留标识符  
- **关键字** ![[Pasted image 20230903173848.png]]  
- **保留标识符**包括以下划线字符开头的标识符和标准库函数名,如 printf()
# 三. 数据和 C  
## 1.变量与常量数据  
- **常量**: 在程序使用前就已经设定好 在整个程序的运行过程中没有变化  
- **变量**: 在程序运行期间可能会改变或被赋值  
## 2. 数据: 数据类型关键字  
- int long short unsigned char float double signed void `_Bool` `_Complex` `_Imaginary ` 
- **关键字含义**
	- signed 用于提供基本整数类型的变式，例如 unsigned short int 和 long long int  
	- char 关键字用于指定字母和其他字符（如:# $ % `*`）和较小的整数
	- float、double 和 long double 表示带小数点的数 
	- `_` Bool 类型表示布尔值 (true 或 false), `_  Complex ` 和  `_ Imaginary ` 分别表示复数和虚数
- **位,字节,字**  
	- **位** (bit)存储 0 或 1  
	- **字节**一个字节为 8 位;有 256 种可能  
	- **字** 是设计计算机是给定的自然存储单位 目前大多数为 32 位和 64 位  
- **整数**: 没有小数部分的数  
- **浮点数**: 实数 (带小数部分)
## 3. C 语言的基本数据类型  
- ### int 类型 (有符号整型)  
	- [[计算机科学导论#^44bd5b|int类型存储方式]]  
	- 取值范围 16 位为-32768~32767 (-2<sup>15</sup>~2<sup>15</sup>-1)  
	- **初始化变量**: 为变量赋一个初始值  
	- %d (十进制);%o (八进制); %x (十六进制) 打印变量  
		- 显示各进制数的前缀0、0x 和0X 需要加# `% #o`  例如: 3F 使用 `%X`; OX3A 使用 ` % #X `
		- [[计算机科学导论#^8c4185|进制转换]]  
- ### 其他整数类型  
	- **short int** `%hd` 常用于较小数值的场景节省空间 (有符号) 16 位  
	- **long int** `%ld` 较大的数比较占用空间 (有符号) 16 位或者 32 位(*一般为 32 位*)  
	- **long long** `%lld;%llu;%#llo;%#llx` 占据64 位 (有符号)  
	- **unsigned int** `%u` 为正整数 (无符号) 16 位的范围 (0~2<sup>16</sup>-1)  
	- *signed 是强调使用有符号类型的意图可以省略*
	- long 常量  
		- 八进制和十六进制常量被视为 int 类型  
		- 如果数值过大依次使用unsigned int、long、unsigned long、long long 和 unsigned long long 类型  
		- 把⼀个较小的常量作为 long 类型对待: 在值的末尾加上 l 或者 L 后缀 (也可用于八进制和十六进制)
			- 同理: long long 为 LL 后缀; unsigned long long 为 ULL  
	- **整数溢出**(溢出行为是未定义行为)
- ### 使用字符: char 类型
	- 实际上存储的是整数.例如:在 **ASCII 码**中,整数65 代表大写字母 A  
		- **ASCII 码**:0~127 由七位二进制数表示
			- 48~57 表示'0'~'9'
			- 65~90 表示'A'~'Z'
			- 97~122 表示'a'~'z'
		- **char 类型**为 8 位存储单元  
	- **字符常量初始化**  
		- 例如: `char grade = 'A' ` 必须要加单引号  
		- 在 C 语言中,用单引号括起来的单个字符被称为**字符常量**  
		-  ![[Pasted image 20230914174807.png]]  
		- 对于'ABCD'把四个独立的 8 位 ASCII 码存储在一个 32 位中 *但把'ABCD'赋值给 char 则 char 为'D'   
	- **非打印字符**  
		- 注意:\\Ooo 前面的 O 可以省略 也表示八进制 ![[Pasted image 20230905180749.png]]  
		- **行为字符表示方法**   
			- 1. 使用 ASCII 码 `char beep = 7`  
			- 2. 使用特殊的符号序列 (见上图: **转义序列**) `char ner = '\n' `  
				- 报警字符不得改变**活跃位置**(显示设备中下一个字符将出现的位置)  
				- ![[Pasted image 20230905182923.png]]  
			- 3. 用十六进制形式表示字符常量 ('\\xF')  
				-  反斜杠后面跟⼀个 x 或 X，再加上1~3位十六进制数字  
	- **打印字符**(%c)  
	- **有符号还是无符号**  
		- 可以在 char 前加上 signed (有符号) 或 unsigned (无符号)  
		- 无符号的 char 类型在处理小整数时很好用  
- ### -Bool 类型  
	- 表示**布尔值** (逻辑 true 1 和 false 0)  
	- 也是一种整数类型 原则上占一位  
- ### 可移植类型: stdint. h 和 inttypes. h  
	- stdint.h (*可以不用 stdint.h 使用 int32_t 移植的话需要使用 stdint.h*)  
		- **精确宽度整数类型**  
			- int32_t  (这些是前缀)  
			- 整数类型的宽度正好是32 位  
			- 计算机底层可能不支持  
		- **最小宽度类型**  
			- int_least8_t   
			- 可容纳8位有符号整数值的类型中宽度最小的类型  
		- **最快最小宽度类型**  
			- int_fast8_t  
			- 系统中对8位有符号值而言运算最快的整数类型  
			- 可使计算达到最快的类型  
		- 其他  
			- 最大的有符号整数类型**intmax_t**  
			- 最大的无符号整数类型**uintmax_t**  
	- inttypes. h  
		- PRId32 字符串宏来打印 int32_t 类型的值  
	- ![[Pasted image 20230906164743.png]]  
		- 该程序最后⼀个 printf()中，参数 PRId32被定义在 inttypes.h 中的"d"替换等价于: ![[Pasted image 20230906164854.png]] 多个连续的字符串组合成一个字符串 ![[Pasted image 20230906165045.png]]  
- ### float、double 和 long double   
	- 计数法 ([[计算机科学导论#^296905|存储方式]])  
		- 科学计数法: 1.0 x 10<sup>9</sup>   
		- 指数计数法: 1.0e9 或 1.0E9 (不可以加空格)  
	- float: 32 位表示 8 位指数 1 位符号 23 个尾数 (有效数) ![[Pasted image 20230824025433.png]]  
	- double: 64 位表示 11 位指数 1 个符号 52 个尾数 ![[Pasted image 20230824025454.png]]  
	- **浮点数常量**  
		- 正号可以省略; 小数点和指数不可同时省略  
		- 在程序中可以 1.0 或者 1E2 (无空格) 表示  
		- *输入的浮点数默认为 double* 可以加后缀 f 来表示 float l 表示 long double   
			- **添加 f 后缀的好处**: 2.0 x 2.0 运算时为两个 double 类型 结果需要截断 (影响速度) 而两个 f 则不需要  
		- **十六进制表示**  
			- 加上 ox 前缀; 用 p 和 P 代替 e 和 E .例如: oxa.1fp10 表示十六进制的 a.1f x 2<sup>10</sup>   
			- p 是指 2 的幂; e 是 10 的幂   
	- **打印浮点值**  
		- **%f** 打印**十进制**的 float 类型  
		- **%e** 打印**指数**计数法的浮点数  
		- **%a** 打印**十六进制的指数**计数法的浮点数  
		- 在前面加上 l 可打印对应的 long 类型  
			- **%lf** 打印 **long double**  
	- **浮点值的上溢和下溢**  
		- 上溢 (现在会输出*无穷大*)  
		- 下溢 (损失精度 可能出现较大误差 下溢后输出 nan 或 NAN)  
		- **舍入错误**: 精度不够导致某几位上的数据丢失  
		- [[计算机科学导论#^c95a9e|上溢和下溢的详细介绍]]  
- ### 复数和虚数类型  
	- *3 种复数类型*  
		- float_Complex (包含**两个** float 的值 分别表示**实部和虚部**)  
		- double_Complex  
		- long double_Complex  
	- *3 种虚数类型*  
		- float_Imaginary   
		- double_Imaginary  
		- long double_Imaginary  
	- complex. h 头文件中可以用 complex 代替_Complex; imaginary 代替_Imaginary 用 I 代替-1的平方根  
		- 例如: float complex a = x x x ;  
		- 为何 C 标准不直接用 complex 作为关键字来代替_Complex?  
		   *因为在此之前有许多人用到了 complex因此它不能变成关键词*  
- ### 其他类型  
	- 字符串  数组  **指针**  结构  联合  
	-  **声明变量**  
		- 可以同时声明多个变量: ![[Pasted image 20230907024222.png]]  
		- 可以在声明变量的同时初始化变量: ![[Pasted image 20230907024258.png]]  
- ### 类型大小  
	- `printf ( " %zd "  sizeof( int ) )` 当前系统指定类型的大小 (**sizeof** 单位**字节**)  
	- C99 和 C11 提供 %zd ; 也可使用%u 或  %lu   
		- printf()语句都被分为两行只要**不在引号内部**或**⼀个单词中间**断行就可以 ![[Pasted image 20230907025031.png]]  
## 4. 使用数据类型  
- ![[Pasted image 20230907150239.png]]  
	- C 编译器把浮点数转换成整数时 会**丢弃小数部分 不会四舍五入**  
		- 例如: int a=3.1 则 a=3 (在赋值时会出现这种情况)  
		- 但是在 **printf** 和 **scanf** 中 ("%d", 3.1) 则会出错,而不是 3  
	- C 只保证了 float 类型前六位的精度 
	- 允许编写**混合数据类型**的表达式 (例如: `int a=1;printf("%lf",a*1.1);` 这时输出 1.1 而不是 1; a x 1.1 为 double 类型) 
- 大多数情况下有以下约定  
	- 用 i_前缀表示 int 类型 ; 例如: i_smart  
	- 用 us_前缀表示 unsigned short 类型 ; 例如:us_versmart  
## 5. 参数和陷阱  
- printf ()括号中的**一个字符串**为一个参数  
	- 但是参数是可变的例如: printf ("%d %d", a ,b); 这其中就有 3 个参数  
	- **参数**之间用**逗号**隔开  
- scanf ("%d"&a); 为两个参数  
- *注意参数的数量类型相匹配*  
## 6. 转义序列 
- 可以定义 char 字符类型使用   
	- char a='\\n';  
	- printf ("%c" a);  
- 也可以直接在 printf 中当作字符使用 (printf 双引号内的是**字符串**)  
	- printf ("\\n")  
- *一些转义字符可能与现代的图形接口兼容*
- **刷新输出**
	- 最初 printf ()语句把输出发送到**缓冲区**(中间存储区域), 然后发送到屏幕 
	- **刷新缓冲区**: 缓冲区的数据发送到屏幕或文件
	- C 标准规定: 当*缓冲区满*, *遇到换行字符*或*需要输入时*刷新缓冲区 (另一种刷新缓冲区的方法是**fflush()函数**)
# 四. 字符串和格式化输入/输出
## 1. 前导程序
- 用**数组**存储**字符串**, 每个字节存储一个字符值
- **%s** 转换说明 (name 和&weight 都是地址)
- *数组是一种**特殊**的指针* ![[Pasted image 20230909205004.png]]
## 2. 字符串简介
- **字符串**: 一个或多个字符的序列
	- printf ("这里面是字符串");
	- char a[ ] =我也是字符串; printf ("%s", a);
	- 也可以声明多个 char 字符, 再放入数组中 (**在末尾加一个\\0**, 不加也可以)
- ### char 类型数组和 null 字符
	- 字符串存储在连续的 char 类型的数组中
		- *空格也是一个字符, 字符串末尾还有\\0*
	- **空字符**\\0不是数字 0, 但是在 ASCII 编码中为 0 (**非打印字符**)
		- 数组的容量是**字符数+1**
		- \\0 是 char a=0; 而不是 char a='0'
	- **数组**
		- 由连续的存储单元构成, 或者说**同类型数据元素的有序序列**, 存储在**相邻**的存储单元中
		- char name[40]; 40 是存储单元数量, 可以不写, **系统会根据字符数自动调节**
- ### 使用字符串
	- printf ()和 scanf ()双引号内的文本是一个字符串,*编译器会在末尾加上空字符*
	- scanf ()只读取 Angela Plains 中的 Angela, 在遇到**第一个空白**(**空格, 制表符\\t,\\v 或换行符\\n**)时不再输入
		- scanf 只会读取一个单词而不是一句话
		- 其他输入函数: **fgets()**, 用于读取一般字符串 (包括空白)
	- 字符和字符串
		- 'x'是一个字符
		- "x"是一个字符串, 包含'x','\\0'
- ### strlen ()函数
	- sizeof 和 strlen 
		- sizeof 占据的字节
		- <font color="#ffff00">strlen</font> 字符长度 (不包括'\\0')
	- ![[Pasted image 20230910230350.png]]
		- `char name[40]` sizeof 得到 40 
		- strlen 是 11 (只有前 11 个用于存储)
	- *sizeof 对象是类型时必须使用 ()* 例如: sizeof (char); *对象是特定量时可有可无*
## 3. 常数和 C 预处理器指令 
- 定义常量
	- 使用变量的缺点: 程序可能无意间改变其数值 
	- C 预处理器 `#define TAXRATE 0.015` 
		- **编译时替换**:编译时,程序中的 TAXRATE 都会替换成 0.015
		- **明示常量** `#define TAXRATE 0.015`
			- 在程序中不能⽤圆括号代替花括号
		- *常量一般使用大写; 无"="和";"* 
- ### const 限定符
	- 只读不写, 定义后不能改变
- ### 明示常量
	- limits. h 整数类型大小限制及实现他的明示变量 
		- 例如: CHAR_BIT char 类型的位数
		- 表示效果
			- MAX 最大值 
			- MIN 最小值
			- `BIT` **位数**
		- 类型
			- `CHAR` char 类型
			- `SCHAR` signed char 类型
			- `UCHAR` unsigned char 类型
			- `INT` int 类型 
			- `UINT` unsigned int 类型
			- `LLONG` long long 类型
	- float. h
		- FLT_DIG 和 DBL_DIG，分别表示 float 类型和 double 类型的有效数字(**尾数**)位数
		- DBL 和 LDBL,分别表示 double 和 long double 类型
		- **明示变量**
			- `FLT_MANT_DIG` float 类型的尾数位数
			- `FLT_DIG` float 类型的最少有效数字位数（十进制）
			- `FLT_MIN(MAX)_10_EXP` 带全部有效数字的 float 类型的最小 (最大)负指数（以10为底）
			- `FLT_MIN (MAX)` **保留全部精度**的 float 类型最小 (最大)正数
			- `FLT_EPSILON` 1.00和比1.00⼤的最小 float 类型值之间的差值*1.192093e-07*
	- 例: printf("%d %e",FLT_DIG,FLT_EPSILON)
## 4. printf ()和 scanf ()
- 输出/输入函数，或简称为 I/O 函数
- 工作原理基本相同:**都使用格式字符串和参数列表**
- 不同:
	- printf()函数使⽤变量、常量和表达式
	- scanf()函数使⽤**指向变量的指针**
- ### printf ()函数
	- 转换说明汇总 ![[Pasted image 20230914165618.png]]
- ### 使用 printf ()
	- 格式:
		- printf( 格式字符串, 待打印项1, 待打印项2,...);
		- **格式字符串**包括**实际打印的字符**和**转换说明**
		- 可以这样![[Pasted image 20230912093423.png]]
	- 打印%要使用两个%
- ### printf ()的转换说明修饰符
	- *在%和转换字符之间插入修饰符可修饰基本的转换说明*
	-  ![[Pasted image 20230911222143.png]]![[Pasted image 20230911181600.png]] ![[Pasted image 20230911181613.png]]
	- stddef. h 头文件把**size_t** 定义成系统使⽤ sizeof 返回的类型 (称为**底层类型**)
	- **ptrdiff_t** 类型和 **t** 修饰符来表示**系统使⽤的两个地址差值**的底层有符号整数类型
	- ![[Pasted image 20230911222011.png]]
	- 例子:
		- 宽度  ![[Pasted image 20230911222928.png]]
		- 小数点 ![[Pasted image 20230911222900.png]]
			- 转换说明%<font color="#c0504d">0</font>10.2f 的第1个0是标记,句点 (.)之前,标记之后的数字(本例为10)是指定的字段宽度
		- `#的用法` ![[Pasted image 20230911223517.png]] ![[Pasted image 20230911223546.png]]
			- *如果0标记和精度一起出现，0标记会被忽略*
		- ![[Pasted image 20230911223914.png]]
			- *精度限制了待打印字符的个数;.5告诉 printf()只打印5个字符*
			- *-标记使得文本左对齐输出*
- ### 转换说明的意义
	- **转换说明**
		- 把以二进制格式**存储在计算机中的值**转换成**⼀系列字符**(字符串)以便于显示
		- 例如:%x 转换说明把(01001100)转换成十六进制记数法4c
		- 转换说明是**翻译说明**，%d 的意思是*把给定的值<font color="#ffff00">翻译</font>成十进制整数文本并打印出来*
	- **转换不匹配**
		- 转换说明的匹配
			- 打印 int 类型可使用%d,%x,%o
			- 打印 double 类型可使用%f,%e,%g
		- 系统使⽤ [[计算机科学导论#^4c7131|二进制补码]]来表示有符号整数
		- 还可能出现[[计算机科学导论#^917111|截断]] 
			- 例如: 用一字节的 char 类型的转换说明%c 打印 2 字节的 int 类型, 只打印后一字节
		- 使用%e 打印 long int 变量错误原因
			- %e 让 printf()函数认为待打印的值是 double 类型 (double 8字节)当 printf()查看4字节的值时,还会查看相邻4字节;然后将8字节单元中的位组合解释成浮点数
	- *float 类型的值作为 printf() 参数时会被转换成 double 类型*
	- *printf()语句有其他不匹配的地⽅，即使⽤对了转换说明也会⽣成虚假的结果*
	- **参数传递**
		- 程序把传入的值放入被称为**栈**的内存区域
		- 会依次按照转换说明所需取的字节数读取
			- 例如:printf("%ld %ld", n1, n2)(long 类型 4 个字节, double 类型 8 个字节)
			- n1=3.0; 则第一个%ld 取 n1 的前 4 个字节; 第二个%ld 不是取得 n2 而是 n1 的后四个字节
		- ![[Pasted image 20230912092304.png]]
	- **printf ()的返回值**
		- printf()的返回值是**待显示字符的个数**
		- ⽤rv = printf(...);的形式把 printf()的返回值赋给 rv(rv 的值是 printf 输出的字符串中的**字符数**)
	- **打印较长的字符串**
		- 在字符串中,可使⽤\\n 换⾏,不可用 Enter 换⾏
		- 字符串断行方法 ![[Pasted image 20230912093533.png]]
		- *⽤反斜杠（\\）和 Enter 键组合来断⾏;在下⼀⾏开始 (不能缩进)继续输出*
- ### 使用 scanf ()
	- 简单规则
		- scanf()读取基本变量类型的值,在变量名前加&
		-  scanf()把字符串读入字符数组中,不⽤&
	- 在每个**输入项**之间输入至少⼀个换⾏符、空格或制表符 (可以输入多个, 都不会读取)*但是除了%c 读取字符会读取每一个空格*
		- 例如:scanf("%d%d", &n, &m)与 scanf("%d %d", &n, &m) 的⾏为相同
	- <font color="#ffff00">转换说明的不同</font>
		- printf ()对于 float 和 double 都使用%f (%e,%g)
		- scanf ()对于 float 使用%f (%e,%g); 而对 double 使用 l 修饰
	- **转换说明的修饰符**
		- 必须按照 `*`,数字, hh, ll, (h,l,L), j, z, t 的顺序 ![[Pasted image 20230912100247.png]]
	- **从 scanf ()角度看输出**
		- 使⽤带多个转换说明的 scanf(),在第1个出错处停止"**读取输入**"
		- *%s 会读取所有非空格字符, 遇到空白就停止*(使用最大字符宽度也不能让只有⼀个%s 的 scanf()读取多个单词; 但 printf 可以输出整句话, 包括空格)
	- **格式字符串中的普通字符**
		- 可以把普通字符放在格式字符串中; 例如 `scanf("%d,%d",&a,%b)` 则要输入 `2,3`
		- *空格在%c前,scanf ()会跳过空格,从第1个非空白字符开始读取*
			- scanf ("%c", &ch)从输⼊中的第1个字符 (可以是空白字符)开始读取
			- scanf (" %c", &ch)从第1个非空白字符开始读取
	- **scanf ()的返回值**:scanf()函数返回成功读取的项数 (**类似 printf 返回值**)
		- 例如: `status = scanf("%ld", &num);` scanf()成功读取⼀个整数,就把该数存⼊num 并返回1，然后将返回值赋给 status
		- 1.**返回-1**:当 scanf()检测到“文件结尾”时,会返回 EOF
			- （EOF 是 stdio.h 中定义的特殊值，通常⽤ `#define` 指令把 EOF 定义为-1)
		- 2.**返回 0**:没有读取任何项,且需要读取⼀个数字却输⼊⼀个非数值字符串
- ### printf ()和 scanf ()的 `*` 修饰符
	- printf ()中的 `*`
		- 不预先指定字段宽度,通过程序来指定,那么可以⽤ `*` 修饰符代替字段宽度
		- 例如: printf ("%2.3f", c); 可以写成 `printf ("%*.*f",a=2,b=3,c);`
	- scanf ()中的 `*`
		- 把 `*` 放在%和转换字符之间时,会使 scanf()跳过相应的输入项
		- 例如: `scanf("%*d %*d %d", &n);` 前两个被跳过 
- ### printf ()的用法提示
	- %9d 类似的用于数据的对齐
	- %.2f 可以更美观
	- **本地化设置**
		- 例如: 在荷兰语言环境下"." 是逗号","
		- C 标准有两个本地化设置: "C"和" "(空字符串)
# 五. 运算符, 表达式和语句
## 1. 基本运算符
- **pow() 函数**⽤于**指数**运算. 例如:pow(3.5, 2.2)返回3.5的2.2次幂
- =,+,-, `*`,/  都是二元运算符
- ### 赋值运算符:=
	- 左侧是变量名, 赋值从左往右
	- a=a+1:找出变量 a 的值,把该值加1,然后把新值赋值变量 a
	- **标识对象的方法**
		- 1. 使用变量名
		- 2. 指定数组的元素, 结构的成员
		- 3. 使用指针表达式
	- 术语:
		- **数据对象**: 
			- 概念:用于存储**值**的**数据存储区域**
			- 对象:实际的数据存储
			- 左值:用来表示或定位存储位置的标签
		- **左值**
			- 概念:标识**特定数据对象**的名称或表达式
			- 一些左值不能放在赋值的左侧: <font color="#ffff00">const 变量</font>
			- 赋值运算符的左侧是**可修改的左值**(又叫**对象定位值**)
		- **右值**(**表达式的值**)
			- 概念:能赋值给可修改左值的量,本身不是左值
			- 可以是常量, 变量或其他可求值的量
		- **运算对象**(项)
			- 运算对象是运算符操作的对象
			- 例如:赋值运算符左侧的"项"
	- *可进行多次连续赋值, 顺序**从右到左***
- ### 符号运算符
	- +-作加法减法运算符:**二元运算符**
	- +-作符号运算符时:**一元运算符**
- ### 除法运算符
	- **截断**:整数除法结果的丢弃小数部分 (不是四舍五入)
	- **趋零截断**: 当结果是负数时, 直接丢弃小数部分
- ### 运算符优先级
	- **表达式树**![[Pasted image 20230913204648.png]]
	- 优先级 (*!>算术>关系>&&>||>赋值*)
		- **初级运算符**( )、[ ]、->、.  高于**单目运算符**高于**算数运算符**(先乘除后加减)高于**关系运算符**高于**逻辑运算符**(不包括!) 高于**条件运算符**高于**赋值运算符**高于**逗号运算符**
		- 赋值,条件,单目运算符的平级间顺序**从右至左**, 其他都是**从左到右**
		- ![[Pasted image 20230913223039.png]]![[Pasted image 20230913223100.png]]![[Pasted image 20230913223121.png]]![[Pasted image 20230913223143.png]]
## 2. 其他运算符
- ### sizeof 运算符和 size_t 类型
	- sizeof (%zd)运算符以**字节**为单位返回运算对象的⼤小
	- 运算对象是类型,必须⽤圆括号括起来 (sizeof (int))
	- **sizeof** 返回**size_t** 类型的值
		- typedef 机制:允许程序员为现有类型创建别名
		- 例如: typedef double real;real 是 double 的别名
- ### 求模运算符:%
	- 整数运算, 取余. 例如:13%5 (读作“13 求模5”)得 3
	- *不同符号的数求模, 以第一个数的符号为准*
- ### 递增递减运算符:++  --
	- **++a ()先加 1 再取值**
	- **a++ ()先取值再加 1**
	- 一个良好的习惯
		- 如果不确定时, 可以分开使用
		- `b = ++i; // 如果使用i++，会得到不同的结果`
		- `++i; // 第1⾏ b = i; // 如果第1行使用i++,并不会影响b的值`
	- 递减运算符与递增运算符类似
- ### 注意事项
	- 不要一次用太多的递增递减运算符 
	- *⼀个变量出现在⼀个函数的多个参数中,不要对该变量使⽤递增或递减运算符*
		- 例如: `ans = num/2 + 5*(1 + num++);` 可能先计算 num/2, 也可能先计算 num++(这时会改变 num 的值, 使 num/2 的值改变)
	- ⼀个变量多次出现在⼀个表达式中，不要对该变量使⽤递增或递减运算符
		- 例如: n = 3; y = n++ + n++;
		- 原因: **副作用在序列点前结算**, 但未说明是运算后递增还是递增后运算
## 3. 表达式和语句 
- ### 表达式
	- 组成: **运算符**和**运算对象**(运算符操作的对象)
	- 表达式的值: 与赋值表达式**左侧**值相同
- ### 语句
	- 不同点
		- `a=4` 是表达式
		- `a=4;` 是语句
	- **表达式语句**:以分号结尾的表达式
		- 声明不是表达式语句 (因为去掉分号不是表达式) 例如: `int a; `
	- **简单语句**
		- 最简单的语句是空语句 `;    //空语句`
		- (部分)语句可以**改变值**或**调⽤函数**; 是条完整的**指令**
			- 不是所有的指令都是语句;不是所有的语句都可以改变值或调⽤函数 (空语句)
			- 例如: x = 6 + ( y = 5 );y = 5是⼀条完整的指令,但它只是语句的⼀部分
	- **复合语句**(块)
		- ⽤{花括号}括起来的⼀条或多条简单语句
		- 应用: while, for循环, if 条件语句
	- **函数表达式语句**会引起**函数调⽤**
		- while 语句是⼀种**迭代**语句或**结构化**语句
- ### 副作用和序列点
	- **副作用**
		- 定义:对**数据对象**或文件的**修改** `states = 50;`
		- 解释: `states = 2+3;`
			- <font color="#ffff00">主作用</font>: 对表达式求值
			- 副作用:把变量 states 的值改为5
		- 应用:
			- 递增递减运算符就是使用其副作用
			- printf ()显示的信息也是副作用
	- **序列点**
		- 定义:程序执⾏的点 (**分号标记序列点**)
		- 作用:所有副作⽤都在进入下⼀步之前 (**在分号前**)发⽣
		- **完整表达式**
			- 定义: 完整表达式**不**是另⼀个更⼤表达式的**子表达式**
			- 联系: 完整表达式的结束是⼀个序列点
## 4. 类型转换
- **升级和降级**
	- **升级**:类型转换从较小的类型转换为较大类型
	- **降级**: 类型转换从较大的类型转换为较小类型
- 类型的**级别**: long double、double、float、 unsigned long long、long long、unsigned long、long、 unsigned int、int
	- 当 long 和 int 的⼤小相同时,unsigned int 比 long 的级别⾼
- **转换**
	- 1.类型转换出现在表达式时,char 和 short 都会被⾃动转换成 int
	- 2.在赋值表达式语句中,计算的最终结果会被转换成被赋值变量的类型
	- 3.当作为函数参数传递时，*char 和 short 被转换成 int，float 被转换成 double*
	- 4.涉及两种类型的运算,两个值会被分别转换成两种类型的更⾼级别
- 待赋值的值与目标类型不匹配 
	- a=b; a 的类型为**目标类型**; a 是**被赋值变量**; b 是**待赋值的值**
	- ![[Pasted image 20230914123415.png]]
- **强制类型转换运算符**
	- **组成**:圆括号和它括起来的类型名 ` (int)`
	- 在某个量前面放置⽤(圆括号)括起来的类型名,该类型名就是希望转换成的目标类型
		- 例如: `mice = (int)1.6 + (int)1.7; ` mice=2
		- `mice = 1.6 + 1.7; ` mice=3 (先计算后截断)
	- 在函数调用时也可使用 `pound ((int)f);`
	- 使⽤**强制类型转换运算符**进⾏**显式转换**, 更直观
# 六. C 控制语句: 循环
- **伪代码**:⽤简单的句子表示程序思路的⽅法
# 1. while 语句
- **形式**: while (测试条件) {复合语句} ;
- 每次循环都被称为⼀次**迭代**
- 入口条件 (圆括号中的)
- ### 终止 while 循环
	- 测试表达式的值有变化,表达式最终要为假
	- break 和 if 语句
- ### while 循环的形式
	- while (条件){复合语句};
	- 几种**易错**情况
		- while (条件); {复合语句};--循环体内为空语句
		- while (条件) 复合语句;--只会生效一条
	- 循环体使用空语句的情况
		- `while (scanf("%d", &num) == 1);` 跳过整数输⼊
		- 这个分号要独占⼀⾏, 提高代码可读性
## 2. 用关系运算符和表达式比较大小
- **关系运算符** "> < >= <= == !="
	- 不能用关系**运算符**比较字符**串**
	- 关系**表达式**比较字符时, 使用机器字符码 (ASCII)
	- **比较浮点数**时少使用"="
		- 原因:浮点数的舍入误差
- ### 真假
	- `while (goats)` 等价 `while (goats != 0)`
	- 关系表达式: 真>>求值为 1; 假>>求值为 0
	- **真** : 非 0 值 ;  **假**: 0
- ⼀个**无限失败**的循环 ( == 换成 = )
	- 当 scanf()把 q 作为整数读取时失败后,把 q 留下,下次循环时,scanf()从上次读取失败的地⽅（q）开始读取，还会失败
- ### _Bool 类型
	- **布尔变量** 
		- 定义:表示真假的变量
		- 只能存储1 (真)或0 (假)
		- *非 0 数值都会被设置为 1*
	- 使用示例: `bool = (scanf("%ld", &a) == 1); `
		- scanf 的返回值与 1 比较, 如果返回值 >=1 就为真, 则 bool=1
	- **stdbool.h 头文件** 
		- _ Bool 的别名 bool
		- true 和 false 定义为1和0的符号常量
		- 可以与 C++兼容:C++把 bool、true 和 false 定义为关键字
## 3. 不确定循环和计数循环
- **不确定循环**:测试表达式为假前,不知道要执⾏多少次循环
- **计数循环**:执⾏循环前知道要重复执⾏多少次
	- 步骤: 
		- 1.必须初始化计数器
		- 2.计数器与有限的值作比较
		- 3.每次循环时递增计数器
## 4. for 循环和 do while 循环
- ### for 循环 
- **形式** 
	- for (初始化; 判断条件; 改变量){复合语句}; 
	- 可以**省略**⼀个或多个表达式,但不能省略**分号**
		- 要保证不是**无限循环**
		- 表达式 2 省略后为**真** (1)
- **步骤**
	- ![[Pasted image 20230915154841.png]]
- 注意事项
	- **表达式 1** 在整个循环中只执行一次; 可以是其他表达式
		- 例如: `for (printf("abc\n"); num != 6;)`
	- **表达式 1,2** 中可以使用 char 字符, 也可以使用不同变量
		- 例如: `for (x = 1; y <= 75; y = (x++ * 5) + 50)`
	- **表达式 3** 中可以使用 a=a+10; a=a* 1.1...
- ### 逗号运算符和其他运算符
	- **其他运算符** += -= `*=` /= %=
		- a+=1; 等效于 a=a+1;
	- **逗号运算符**
		- 在表达式中使用逗号隔开, 可初始化多个变量
			- 例如: `for (a=1,b=2;a<=16;a++,b+=2)`
		- **逗号运算符**把两个表达式连接成⼀个表达式,并保证最左边的表达式最先求值
		- 逗号是**序列点**,左侧项的副作⽤在执⾏右侧项前发⽣
		- *整个式的值逗号表达是右侧项的值*
			- 例如:(b,c)== c
	- **注意**a=b,c; 和 a=(b,c);不同
		- a=b,c 等效于 a=b; c; 把 b 的值赋给 a, `c;` 什么也不做
		- a=(b,c); 把 c 的值赋给了 a
	- **逗号分隔符**
		- 下列语句中逗号为分隔符,不是逗号运算符
		- int a, b; printf ("%d %d\\n", a, b);
- ###  出口条件循环: do while 
	- **入口条件循环**(while 和 for)
		- 在循环的每次迭代前检查测试条件
		- **可能不执⾏**循环体中的内容
	- **出口条件循环**(do while)
		- 在循环的每次迭代后检查测试条件
		- 至少执⾏循环体中的内容**⼀次**
	- **形式**: do {复合语句} while (测试条件);
## 5. 嵌套循环
- **嵌套循环**:在⼀个循环内包含另⼀个循环, 常用于按行按列显示数据
- **嵌套变式**:内层循环开始打印的字符取决于外层循环的迭代次数 ![[Pasted image 20230915193138.png]]
## 6. 数组简介
- **数组**是按顺序存储的⼀系列类型相同的值
- 通过**下标**访问数组中单独的**项**或**元素**
	- 例如: `a[0] = 3;scanf("%f", &a[4]);`
- 数组的类型可以是任意数据类型
	- **形式**: int a[22];
![[Pasted image 20230915201050.png]]
- ### 在 for 循环中使用数组
	- 使用递增量 (i++) 将值存到数组的每个元素中 `for( i=0; i<10; i++ ) { scanf( "%d", &a[ i ] ) }`
- **模块化**:
	- 原则:把程序划分为⼀些独⽴的单元，每个单元执⾏⼀个任务,
	- 作用:可以提⾼程序的可读性
## 7. 计算幂的程序
- 计算幂的函数 ![[Pasted image 20230915204605.png]]
- 返回值也可以是表达式的值
	- 例如: return 2+a;
- ### 使用带返回值的函数
	- 声明函数、调⽤函数、定义函数、使⽤关键字 return，是定义和使⽤带返回值函数的**基本要素**
	- 为什么在定义中说明了 power()的返回类型为 double,还要单独声明这个函数?
		- 编译器在程序中首次遇到 power()时,需要知道 power()的返回类型
	- **前置声明**预先说明函数的返回类型
	- power()函数的定义在 main()的文件上面,就可以省略前置声明
# 七. C 控制语句: 分支和跳转
- if 语句被称为分支语句或选择语句
- if 语句由复合语句构成, 但整个 if 语句为⼀条语句
## 1. if else 语句
- **if 语句**
	- if 语句被称为分支语句或选择语句
	- if 语句由复合语句构成, 但整个 if 语句为⼀条语句
- **形式**: if (判断条件){复合语句} else {复合语句}
 --- 
- ### 介绍 getcher ()和 putchar ()
	- **getchar ()**
		- 不带任何参数,它从输入队列中返回下⼀个字符 ch=getchar();等效 scanf("%c",&ch);
		- **返回值**是输入字符对应的 ASCII 值
		- 一个 getchar 只能输入一个字符
		- **换行符**'\\n'相当于 **Enter 键**
		- 与循环结合读取**字符串**
	- **putchar ()**
		- putchar(ch); 等效于 printf("%c", ch);
	- getchar()和 putchar()不需要转换说明,只处理**字符**
	- 通常是**预处理宏**,不是真正的函数,定义在 stdio.h 头文件
	- **注意**: 当输入 a 并按下 Enter 键时, 一个 getchar 只能读取一个字符, 换行符会缓存, 则下一个 getchar 会读取换行符 
---
- ### ctype. h 系列的字符函数
	- **isalpha()函数**的参数是⼀个字母,则返回⼀个非零值
		- 应用: if (<font color="#ffff00">isalpha(ch)</font>) 执行语句;
	- **字符映射**函数不会修改原始的参数,只会返回已修改的值
		- tolower(ch); 不改变 ch 的值
		- ch = tolower(ch);  改变 ch 的值
	- ctype.h 头文件中的**字符测试**函数 ![[Pasted image 20230917164719.png]]
		- **标准的**空白字符 (**空格,换⾏符**,换页符,回车符,垂直制表符,**水平制表符或其他本地化定义的字符**）--粗体为标准的
	- ctype.h 头文件中的**字符映射**函数 ![[Pasted image 20230917165503.png]]
- ### 多重选择 else if
	- **形式**: if (判断条件){复合语句}else if (...){...}
	- **else 与 if 配对**
		- **规则**:如果没有花括号,else 与离它最近的 if 匹配，除非最近的 if 被花括号括起来
		- 例如: else 与标记部分配对 ![[Pasted image 20230917214529.png]]
	- ![[Pasted image 20230917224132.png]]
## 2. 逻辑运算符 
- **&&与 ; ||或 ; !非**
- ### 备选拼写: iso 646. h 头文件
	- iso646.h 头文件中有可代替逻辑运算符的拼写 and 代替&&、or 代替||、not 代替!
- ### 求值顺序
	- **逻辑表达式**的求值顺序是从左往右
	- &&和||运算符都是**序列点**
	- 例如:
		- `while ((c = getchar()) != ' ' && c != '\n')`
		- `apples = (5 + 3) * (9 + 6); ` 无法确定先对 `5+3` 还是 `9+6` 求值
	- **高效性**
		- 例如: `if (number != 0 && 12/number == 2)` &&要求两个全为真,如果 number 的值是0，那么第 1个子表达式为假,且不再对关系表达式求值
		- `if (a<b||b++<a+b)` 如果 a< b 为真则跳过后一个子表达式
## 3. 条件运算符 ?:
- **三元运算符**
	- **形式**: <font color="#ffff00">表达式1 ? 表达式2 : 表达式3</font>
		- 如果表达式1为真,整个条件表达式的值与表达式2的值相同; 否则与表达式 3 的值相同
		- 例如: `x = (y < 0) ? -y : y;` 等效于 `if (y < 0) x = -y; else x = y;`
## 4. 辅助循环: continue 和 break 
- ### continue 语句
	- continue 只会影响该层循环
	- 结束这一轮, 开始下一轮